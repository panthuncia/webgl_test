<!DOCTYPE html>
<html>
<head>
    <title>WebGL playground</title>
</head>
<script id="primaryVSSource" type="x-shader/x-vertex">

    in vec3 a_position;
    in vec3 a_normal;
    in vec2 a_texCoord;
    in vec3 a_baryCoord;

    #ifdef GOURAUD
    #define AMBIENT_SCALING_FACTOR 15.0
    layout(std140) uniform PerFrame {
        uniform mat4 u_viewMatrixInverse;
    };

    layout(std140) uniform PerMaterial {
        uniform float u_ambientStrength;
        uniform float u_textureScale;
        #ifndef USE_PBR
        uniform float u_specularStrength;
        #else
        #ifdef GOURAUD
        uniform float u_specularStrength;
        #endif
        #endif
    };

    layout(std140) uniform LightInfo {
        // light attributes: x=type (0=point, 1=spot, 2=directional)
        // x=point -> w = shadow caster
        // x=spot -> y= inner cone angle, z= outer cone angle, w= shadow caster
        // x=directional => w= shadow caster
        uniform vec4 u_lightProperties[MAX_LIGHTS];
        uniform vec4 u_lightPosViewSpace[MAX_LIGHTS]; // Position of the lights
        uniform vec4 u_lightDirViewSpace[MAX_LIGHTS]; // direction of the lights
        uniform vec4 u_lightAttenuation[MAX_LIGHTS]; //x,y,z = constant, linear, quadratic attenuation, w= max range
        uniform vec4 u_lightColor[MAX_LIGHTS]; // Color of the lights

        uniform int u_numLights;
    };
    out vec4 v_fragColor;
    #endif

    //uniform mat4 u_modelMatrix;
    uniform mat4 u_modelViewMatrix;
    uniform mat4 u_projectionMatrix;
    uniform mat3 u_normalMatrix;
    
    #ifdef GOURAUD
    uniform sampler2D u_baseColorTexture;
    #endif

    out vec3 v_normal;
    out vec4 v_fragPos;
    out vec2 v_texCoord;
    out vec3 v_baryCoord;
    
    #ifdef GOURAUD
    // Models spotlight falloff with linear interpolation between inner and outer cone angles
    float spotAttenuation(vec3 pointToLight, vec3 lightDirection, float outerConeCos, float innerConeCos) {
        float cos = dot(normalize(lightDirection), normalize(-pointToLight));
        if(cos > outerConeCos) {
            if(cos < innerConeCos) {
                return smoothstep(outerConeCos, innerConeCos, cos);
            }
            return 1.0;
        }
        return 0.0;
    }
    vec3 calculateLightContribution(int lightIndex, vec3 fragPos, vec3 viewDir, vec3 normal, vec3 albedo) {
        int lightType = int(u_lightProperties[lightIndex].x);
        vec3 lightPos = u_lightPosViewSpace[lightIndex].xyz;
        vec3 lightColor = u_lightColor[lightIndex].xyz;

        vec3 dir = u_lightDirViewSpace[lightIndex].xyz;
        
        float constantAttenuation = u_lightAttenuation[lightIndex].x;
        float linearAttenuation = u_lightAttenuation[lightIndex].y;
        float quadraticAttenuation = u_lightAttenuation[lightIndex].z;
        
        float outerConeCos = u_lightProperties[lightIndex].z;
        float innerConeCos = u_lightProperties[lightIndex].y;

        vec3 lightDir;
        float distance;
        float attenuation;
        float spotAttenuationFactor = 0.0;

        // For directional lights, use light dir directly, with zero attenuation
        if(lightType == 2) {
            lightDir = dir;
            attenuation = 1.0;
        } else {
            lightDir = normalize(lightPos - fragPos);
            distance = length(lightPos - fragPos);
            attenuation = 1.0 / (constantAttenuation + linearAttenuation * distance + quadraticAttenuation * distance * distance);
        }

        // Unit vector halfway between view dir and light dir. Makes more accurate specular highlights.
        vec3 halfwayDir = normalize(lightDir + viewDir);

        // Calculate diffuse light
        float diff = max(dot(normal, lightDir), 0.0);
        vec3 diffuse = diff * lightColor;

        // Calculate specular light, Blinn-Phong
        float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
        vec3 specular = u_specularStrength * spec * lightColor;

        // Attenuate
        vec3 lighting = (diffuse + 0.1*specular) * attenuation;

        // For spotlights, apply extra attenuation based on the angle
        if(lightType == 1) {
            float spot = spotAttenuation(lightDir, dir, outerConeCos, innerConeCos);
            lighting *= spot;
        }
        
        return lighting;
    }
    #endif

    void main() {
        // Transform the position into view space
        v_fragPos = vec4(u_modelViewMatrix * vec4(a_position, 1.0));
    
        // Transform the normal
        // Normal matrix is calculated as inverse transpose
        // of model-view matrix to modify normals appropriately when object is scaled
        v_normal = normalize(u_normalMatrix * a_normal);

    
        // Pass texcoord to fs
        v_texCoord = a_texCoord;

        // Pass barycentric coords for wireframe
        v_baryCoord = a_baryCoord;


        #ifdef GOURAUD
            vec4 baseColor = texture(u_baseColorTexture, a_texCoord);
            #ifndef SKIP_LIGHTING
                vec3 viewDir = -normalize(v_fragPos.xyz); // view-space
                vec3 lighting = vec3(0.0, 0.0, 0.0);
                for(int i = 0; i < u_numLights; i++) {
                    lighting += calculateLightContribution(i, v_fragPos.xyz, viewDir, v_normal, baseColor.xyz);
                }
                vec3 ambient = u_ambientStrength * baseColor.xyz * AMBIENT_SCALING_FACTOR;
                lighting += ambient;
                vec3 color = baseColor.xyz * lighting;
            #else
                vec3 color = baseColor.xyz * u_ambientStrength;
            #endif
            v_fragColor = vec4(color / (color + vec3(1.0)), 1.0);
        #endif
    
        // Set the position
        gl_Position = u_projectionMatrix * v_fragPos;

    }
</script>

<script id="primaryFSSource" type="x-shader/x-fragment">
    #define PI 3.1415926538
    precision highp sampler2DArray;

    // If we're not using normal mapping, 
    // we want the view-space normals from the vertex shader
    in vec3 v_normal;

    in vec4 v_fragPos;
    in vec2 v_texCoord;  // Received from vertex shader
    in vec3 v_baryCoord;
    #ifdef GOURAUD
    in vec4 v_fragColor;
    #endif

    #define AMBIENT_SCALING_FACTOR 15.0

    #define LIGHT_TYPE_POINT 0
    #define LIGHT_TYPE_SPOT 1
    #define LIGHT_TYPE_DIRECTIONAL 2


    layout(std140) uniform PerFrame {
        uniform mat4 u_viewMatrixInverse;
    };

    layout(std140) uniform PerMaterial {
        uniform float u_ambientStrength;
        uniform float u_textureScale;
        #ifndef USE_PBR
        uniform float u_specularStrength;
        #else
        #ifdef GOURAUD
        uniform float u_specularStrength;
        #endif
        #endif
    };

    layout(std140) uniform LightInfo {
        // Light attributes: x=type (0=point, 1=spot, 2=directional)
        // x=point -> w = shadow caster
        // x=spot -> y= inner cone angle, z= outer cone angle, w= shadow caster
        // x=directional => w= shadow caster
        uniform vec4 u_lightProperties[MAX_LIGHTS];
        uniform vec4 u_lightPosViewSpace[MAX_LIGHTS]; // Position of the lights
        uniform vec4 u_lightDirViewSpace[MAX_LIGHTS]; // Direction of the lights
        uniform vec4 u_lightAttenuation[MAX_LIGHTS]; // x,y,z = constant, linear, quadratic attenuation, w= max range
        uniform vec4 u_lightColor[MAX_LIGHTS]; // Color of the lights

        uniform int u_numLights;
    };

    uniform sampler2D u_baseColorTexture;

    out vec4 fragmentColor;

    // Models spotlight falloff with linear interpolation between inner and outer cone angles
    float spotAttenuation(vec3 pointToLight, vec3 lightDirection, float outerConeCos, float innerConeCos) {
        float cos = dot(normalize(lightDirection), normalize(-pointToLight));
        if(cos > outerConeCos) {
            if(cos < innerConeCos) {
                return smoothstep(outerConeCos, innerConeCos, cos);
            }
            return 1.0;
        }
        return 0.0;
    }

    

    vec3 calculateLightContribution(int lightIndex, vec3 fragPos, vec3 viewDir, vec3 normal, vec2 uv, vec3 albedo) {
        int lightType = int(u_lightProperties[lightIndex].x);
        vec3 lightPos = u_lightPosViewSpace[lightIndex].xyz;
        vec3 lightColor = u_lightColor[lightIndex].xyz;

        vec3 dir = u_lightDirViewSpace[lightIndex].xyz;
        
        float constantAttenuation = u_lightAttenuation[lightIndex].x;
        float linearAttenuation = u_lightAttenuation[lightIndex].y;
        float quadraticAttenuation = u_lightAttenuation[lightIndex].z;
        
        float outerConeCos = u_lightProperties[lightIndex].z;
        float innerConeCos = u_lightProperties[lightIndex].y;

        vec3 lightDir;
        float distance;
        float attenuation;
        float spotAttenuationFactor = 0.0;

        // For directional lights, use light dir directly, with zero attenuation
        if(lightType == 2) {
            lightDir = dir;
            attenuation = 1.0;
        } else {
            lightDir = normalize(lightPos - fragPos);
            distance = length(lightPos - fragPos);
            attenuation = 1.0 / (constantAttenuation + linearAttenuation * distance + quadraticAttenuation * distance * distance);
        }

        // Unit vector halfway between view dir and light dir. Makes more accurate specular highlights.
        vec3 halfwayDir = normalize(lightDir + viewDir);

        // Calculate diffuse light
        float diff = max(dot(normal, lightDir), 0.0);
        vec3 diffuse = diff * lightColor;

        // Calculate specular light, Blinn-Phong
        float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
        vec3 specular = u_specularStrength * spec * lightColor;

        // Attenuate
        vec3 lighting = (diffuse + specular) * attenuation;

        // For spotlights, apply extra attenuation based on the angle
        if(lightType == 1) {
            float spot = spotAttenuation(lightDir, dir, outerConeCos, innerConeCos);
            lighting *= spot;
        }

        return lighting;
    }

    void main() {

        #ifdef WIREFRAME
        // OGL doesn't have a wireframe rasterizer fill mode like DX, so we'll use barycentric coords instead
        float edgeWidth = 0.005;
        if( v_baryCoord.x < edgeWidth||v_baryCoord.y < edgeWidth||v_baryCoord.z < edgeWidth){
            fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);
            return;
        }
        else
            discard;
        #endif

        #ifdef GOURAUD
            fragmentColor = v_fragColor;
            return;
        #endif

        // We're doing light calculations in view space
        vec3 viewDir = -normalize(v_fragPos.xyz); // view-space

        //Parallax occlusion mapping. WIP.
        vec2 uv = v_texCoord;
        uv *= u_textureScale;
        #ifdef USE_PARALLAX
        uv = getContactRefinementParallaxCoords(uv, viewDir);
        #endif

        vec4 baseColor = texture(u_baseColorTexture, uv);
        #ifndef SKIP_LIGHTING
            vec3 normal = v_normal;
            // Accumulate light from all lights. WIP.
            vec3 lighting = vec3(0.0, 0.0, 0.0);
            float normalOffsetBias = 0.05;
            vec4 fragPosWorldSpace = u_viewMatrixInverse * vec4(v_fragPos.xyz+normal*normalOffsetBias, v_fragPos.w);
            int dirLightNum = 0;
            int spotLightNum = 0;
            int pointLightNum = 0;
            for(int i = 0; i < u_numLights; i++) {
                lighting += calculateLightContribution(i, v_fragPos.xyz, viewDir, normal, uv, baseColor.xyz);
            }

            // Ambient lighting,
            vec3 ambient = u_ambientStrength * baseColor.xyz * AMBIENT_SCALING_FACTOR;
            lighting += ambient;
        #else
            float lighting = u_ambientStrength;
        #endif
        vec3 color = baseColor.xyz * lighting;
        // Reinhard tonemapping
        color = color / (color + vec3(1.0));

        // Gamma correction
        //color = pow(color, vec3(1.0 / 2.2));


        // Apply opacity
        float opacity = baseColor.a;
        fragmentColor = vec4(color, opacity);
    }
</script>
<body>
    <canvas id="webgl-canvas" width="800" height="800"></canvas>
    <text> <br>Project 2 by Matthew Gomes <br>
        Controls:<br>
        "m": Toggle wireframe mode<br>
        "e": Increase object subdivisions<br>
        "q": Decrease object subdivisions<br>
        "i": Increase path subdivisions<br>
        "j": Decrease path subdivisions<br>
        "a": Toggle animation<br>
        "l": Toggle lighting mode (Blinn-Phong/Gouraud)<br>
        "n": Toggle Newell face normals<br>
        "z": Add random light<br>
        "x": Add a random object<br><br>
        Extra features: <br>
        1. Camera movement (Orbital camera, drag on canvas and scroll to move)<br>
        2. Newell vertex calculation (press "n" to toggle)<br>
        3. Primary light orbits scene, path shown with lines<br>
        4. Second light orbiting the object, using scene graph for transform inheritance<br>
        5. Arbitrary number of lights (Press "z" to add a light! It will be spawned at a random location, in a random orientation, with a random color, and float around the scene)<br>
        6. Arbitrary number of objects on path (Press "x" to add an object! It will be spawned at the beginning of the path, with a random color and speed)<br></text>
    </text>
    <script src="gl-matrix-min.js"></script>
    <script type="text/javascript" src="globals.js"></script>
    <script type="text/javascript" src="types.js"></script>
    <script type="text/javascript" src="utils.js"></script>
    <script type="text/javascript" src="renderer.js"></script>
    <script type="text/javascript" src="renderer_lines.js"></script>
    <script type="text/javascript" src="main.js"></script>
</body>
</html>
